# 3. 애그리거트

## 리포지터리와 애그리거트

애그리거트는 개념상 완전한 한 개의 도메인 모델을 표현하므로 리포지터리는 애그리거트 단위로 존재한다. Order와 OrderLine을 별도의 테이블에 저장한다고 해도 리포지터리를 각각 만들지 않는다.

리포지터리는 애그리거트 전체를 저장소에 영속화해야 하는데  
Order 래그리거트는 저장할 때 애그리거트에 속한 모든 구성요소를 위한 테이블에 저장해야 한다.  
조회 또한 order 애그리거트는 ORderLine, Orderer 등 모든 구성 요소를 포함하고 있어야 한다.

## ID를 이용한 애그리거트 참조

객체가 다른 객체를 참조하는것 처럼 애그리거트도 다른 애그리거트를 참조한다.  
애그리거트의 관리 주체가 애그리거트 루트이므로 애그리거트에서 다른 애그리거트를 참조한다는 것은 애그리거트의 루트를 참조한다는 것과 같다.

![](../../.gitbook/assets/image%20%2858%29.png)

애그리거트 간의 참조는 필드를 통해 쉽게 구현할 수 있다.

```java
order.getOrderer().getMember().getId()
```

JPA 에서는 @ManyToOne, @OneToMany 와 같은 애노테이션을 이용해서 쉽게 참조할 수 있다.

그런데 필드를 통한 직접 참조는 다음과 같은 문제를 야기할 수 있다.

* 편한 탐색 오용
* 성능에 대한 고민
* 확장 어려움

**첫째** 편한 탐색을 오용하는 경우는  
애그리거트 내부에서 다른 애그리거트 객체에 접근해 쉽게 상태를 변경할 수 있게 된다.

한 애그리거트의 관리 범위는 자기자신으로 한정 해야한다.  
그렇지 않으면 애그리거트 간의 의존 결합도가 높아져 결과적으로 애그리거트의 변경을 어렵게 만든다.

**두 번째** 직접 참고할 경우 성능과 관련된 여러 가지 고민을 해야 한다.  
JPA를 사용할 경우 참조한 객체를 지연\(lazy\) 로딩과 즉시\(eager\) 로딩 두 가지 로딩 방식을 쓸수 있는데  
단순히 연관된 객체를 데이터와 함께 화면에 보여준다면 즉시 로딩이 유리하지만,  
상태를 변경하는 기능일 경우에는 지연 로딩이 유리하다.  
이런 다양한 경우의 수를 고려해서 로딩 전략을 결정해야 한다.

**세 번째** 초기에 단일 서버에 단일 DBMS로 서비스를 제공하다가 사용자가 몰리면 문제가 발생하기 시작한다. 트래픽이 증가하면서 자연스럽게 부하를 분산하기 위해 하위 도메인별로 시스템을 분리하기 시작한다.  
하위 도메인마다 다른 DBMS를 사용할 수도 있는데 이는 더 이상 다른 애그리거트의 참조를 위해 JPA와 같은 기술을 사용할수 없게된다.

이런 문제를 완화하기 위해 ID를 이용한 참조를 한다.

![](../../.gitbook/assets/image%20%2864%29.png)

ID를 이용한 참조는 DB 테이블에서의 외래키를 사용해서 참조하는 것과 비슷하다.  
단, 애그리거트 내의 엔티티를 참조할 때는 객체 레퍼런스로 참조한다.

ID 참조를 사용하면 모든 객체가 연결되지 않고 애그리거트에 속한 객체들만 참조로 연결된다.  
또한, 애그리거트간 의존을 제거하므로 응집도를 높여주고, 구현복잡도 또한 낮아진다.

```java
public class ChangeOrderService {
    @Transactional
    public void changeShippingInfo(OrderId id, shippingInfo newShippingInfo,
            boolean useNewShippingAddrAsMemberAddr) {
        Order order = orderRepository.findById(id);
        
        if (order == null) throw new OrderNotFoundException();
        order.changeShippingInfo(newShippingInfo);
        
        if (useNewShippingAddrAsMemberAddr) {
            Customer customer = customerRepository.findById(
                    order.getOrderer().getCustomerId());
                    
            customer.changeAddress(newShippingInfo.getAddress());
        }
    }
}
```

