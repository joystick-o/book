# 2. 아키텍쳐 개요

## 도메인 영역의 주요 구성요소

도메인 영역의 모델은 도메인의 주요 개념을 표현하며 핵심이 되는 로직을 구현한다.

| **요소**  | **설명**                                                                                                                                                      |
| ------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 엔티티     | <p>고유 식별자를 갖는 객체.<br>도메인의 고유한 개념을 표현.</p><p>도메인 모델의 데이터를 포함하며 데이터와 관련된 기능을 함께 제공한다.</p>                                                                     |
| 밸류      | <p>고유 식별자를 갖지 않는 객체.</p><p>객체의 속성을 표현할 때 사용.</p><p>엔티티의 속성으로 사용될 뿐만 아니라 다른 밸류 타입의 속성으로도 사용될 수 있다.</p>                                                       |
| 애그리거트   | <p>관련된 엔티티와 밸류 객체를 개념적으로 묶은것.</p><p>예를 들어 주문과 관련된<br>Order 엔티티, OrderLine 밸류, Orderer 밸류 객체를 주문 애그리거트로 묶을수 있다.</p>                                          |
| 리포지터리   | <p>도메인 모델의 영속성을 처리.</p><p>DBMS 테이블에서 엔티티 객체를 로딩하거나 저장하는 기능 제공</p>                                                                                           |
| 도메인 서비스 | <p>특정 엔티티에 속하지 않은 도메인 로직을 제공한다.</p><p>할인 금액 계산은 상품, 쿠폰, 회원 등급, 구매 금액등 다양한 조건을 이용해서 구현하는데</p><p>이렇게 도메인 로직이 여러 엔티티와 밸류를 필요로 할 경우 <br>도메인 서비스에서 로직을 구현한다.</p> |

### 엔티티와 밸류

도메인 모델의 엔티티와 DB 테이블의 엔티티는 같지 않다.

도메인 모델의 엔티티는 데이터와 함께 도메인 기능을 함께 제공한다는 점이다.\
예를 들어, 주문을 표현하는 엔티티는 주문과 관련된 데이터뿐만 아니라 배송지 주소 변경을 위한 기능을 함께 제공한다는 것이다.

```java
public class Order {
    //주문 도메인 모델의 데이터
    private OrderNo number;
    private Orderer orderer;
    ...
    
    // 도메인 모델 엔티티는 도메인 기능도 함께 제공
    public void changeShippinginfo(ShippingInfo newShippingInfo) {
        ...
    }
}
```

도메인 관점에서 기능을 구현하고 기능 구현을 캡슐화해서 데이터가 임의로 변경되는 것을 막는다.

다른 차이점은 도메인 모델의 엔티티는 두 개 이상의 데이터가 개념적으로 하나인 경우 밸류 타입을 이용해서 표현할 수 있다는 점이다.

밸류는 불변으로 구현하는 것을 권하는데, 이는 엔티티의 밸류 타입 데이터를 변경할 때 객체 자체를 완전히 교체 한다는 것을 의미한다.

```java
public class Order {
    //주문 도메인 모델의 데이터
    private OrderNo number;
    private Orderer orderer;
    ...
    
    // 도메인 모델 엔티티는 도메인 기능도 함께 제공
    public void changeShippinginfo(ShippingInfo newShippingInfo) {
        checkShippingInfoChangeable();
        setShippingInfo(newShippingInfo);
    }
    
    private void setShippingInfo(ShippingInfo newShippingInfo) {
        if (newShippingInfo == null) throw new IllergalArgumentException();
        this.shippingInfo = new newShippingInfo;
    }
}
```

### 애그리거트

엔티티와 밸류 개수가 많아지면 많아질수록 모델은 점점 더 복잡해진다.\
도메인 모델에서 전체 구조를 이해하는 데 도움이 되는 것이 애그리거트(AGGREGATE) 이다.

애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖는다.\
루트 엔티티는 애그리거트에 속해 있는 엔티티와 밸류 객체를 이용해서 애그리거트가 구현해야 할 기능을 제공한다.

![](<../../.gitbook/assets/image (55).png>)

주문 애그리거트는 Order를 통하지 않고 ShippingInfo를 변경할 수 있는 방법을 제공하지 않는다.

### 리포지터리

도메인 객체를 지속적으로 사용하려면 물리적인 저장소에 보관해야 한다. 이를 위한 모델이다.\
애그리거트 단위로 도메인 객체를 저장하고 조회하는 기능을 정의한다.

```java
public interface OrderRepository {
    public Order findByNumber(OrderNumber number);
    public void save(Order order);
    public void delete(Order order);
}
```

도메인 모델 관점에서 OrderRepository는 도메인 객체를 영속화하는 데 필요한 기능을 추상화한 것으로 고수준 모듈에 속한다.\
구현 클래스는 저수준 모듈로 인프라스트럭쳐에 속한다.

## 요청 처리 흐름

표현 영역은 사용자가 전송한 데이터 형식이 올바른지 검사하고\
응용서비스에 기능 실행을 위임.\
응용 서비스는 도메인 모델을 이용해서 기능을 구현

![](<../../.gitbook/assets/image (65).png>)

응용 서비스는 도메인의 상태를 변경하므로 올바르게 저장소에 반영되도록 트랜잭션을 관리해야 한다.

## 인프라스트럭쳐 개요

인프라스트럭쳐는 표현 영역, 응용 영역, 도메인 영역을 지원한다.\
도메인 영역과 응용 영역에서 인프라스트럭쳐의 기능을 직접 사용하는 것보다\
이 두 영역에 정의한 인터페이스를 인프라스트럭쳐 영역에서 구현하는 것이 더 유연하고 쉽게 만들어준다.

하지만, 무조건 인프라스트럭쳐에 대한 의존을 없애는 것이 좋은 것은 아니다.\
스프링을 사용할 경우 @Transactional, @Table, @Entity 같은 애노테이션은 그냥 사용하는 것이 편하다.\
구현의 편리함은 DIP가 주는 다른 장점만큼 중요하기 때문에 DIP의 장점을 해치지 않는 범위에서 의존을 가져가는 것이 현명하다.

## 모듈 구성

아키텍쳐의 각 영역은 별도 패키지에 위치한다.

![](<../../.gitbook/assets/image (41).png>)

모듈 구조를 얼마나 세분화해야 하는지에 대해 정해진 규칙은 없다.\
한 패키지에 너무 많은 타입이 몰려 코드를 찾을 때 불편한 정도만 아니면 된다.
