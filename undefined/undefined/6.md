# 6장 시퀀스

컬렉션에서 처리는 즉시 발생한다. map이나 filter가 호출될 때 컬렉션의 모든 우너소는 즉시 처리된다. 반면에 시퀀스는 지연 \(lazy\) 처리된다.  
지연 처리 방식은 데이터가 많거나 first 같은 쇼트 서킷 연산의 경우에 도움이 되고 원하는 값을 찾았을 때 시퀀스를 종료할 수 있게 도와준다.

## 지연 시퀀스 사용하기

100부터 200까지의 숫자를 각각 2배로 만든 다음 3으로 나눠 딱 떨어지는 첫 번째 값을 찾고 싶다.

```kotlin
(100 until 200).map { it * 2 } // 100개의 계산
    .filter { it % 3 == 0 }    // 또 다른 100개의 계산
    .first()
    
    
(100 until 200).map { it * 2 } // 100개의 계산
    .first { it % 3 == 0 }
```

특정 조건에 다다를 때까지 오직 필요한 데이터만을 처리하는 방식을 쇼트 서킷이라 부른다.

코틀린 시퀀스는 데이터를 다른 방식으로 처리한다.

```kotlin
(100 until 200).asSequence()    // 범위를 시퀀스로 변경
    .map { println("doubling $it"); it * 2 }
    .filter { println("filtering $it"); it % 3 == 0 }
    .first()
```

이번에는 함수가 올바른 답을 리턴하기 전까지 오직 6개의 연산만을 수행한다.

doubling 100  
filtering 200  
doubling 101  
filtering 202  
doubling 102  
filtering 204

이 예제의 시퀀스에서 filter , first 사용은 중요하지 않다.  
어떤 방법을 사용하든 시퀀스의 각 원소를 다음 원소로 진행하기 전에 완전한 전체 파이프라인에서 처리되기 때문에 오직 6개의 연산만이 수행된다.

시퀀스 API는 중간 연산, 최종 연산이라는 범주로 나뉜다.  
map 과 filter 같은 중간 연산은 새로운 시퀀스를 리턴한다.  
first, toList 같은 최종 연산은 시퀀스가 아닌 다른 것을 리턴한다.  
**중요한 점은 최종 연산 없이는 시퀀스가 데이터를 처리하지 않는다는 점이다.**

