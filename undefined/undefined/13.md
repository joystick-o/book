# 13장 코루틴과 구조적 동시성

코틀린에서 사장 인기 있는 기능 중 하나가 개발자가 동시성 코드를 마치 동시 코드처럼 작성할 수 있게 해주는 코루틴을 지원한다는 것이다.

## 코루틴 빌더 선택하기

새 코루틴을 생성하려면 빌더 함수 runBlocking, launch, async 중 하나를 사용할 수 있다.  
runBlocking 은 최상위 함수인 반면 launch 와 async는 CoroutineScope의 확장 함수다.

CoroutineScope에 정의된 launch와 async가 완전하게 제거될 것이 아니라면 이를 사용하지 말 것을 권장한다.  
launch와 async의 문제점은 시작하는 코루틴이 특정 코루틴 잡에도 할당되지 않고 영구적으로 취소되지 않으면 애플리케이션의 전체 수명주이에 걸쳐 실행된다는 것이다. 따라서 반드시 사용해야 할 이유가 없다면 부디 launch와 async를 사용하지 말자.

### runBlocking 빌더

runBlocking은 명령줄 검증 또는 테스트에 유용하다.  
runBlocking은 현재 스레드를 블록하고 모든 내부 코루틴이 종료될 때까지 블록한다.  
runBlocking 함수 자체는 suspend 함수가 아니므로 보통 함수에서 호출할 수 있다.

```kotlin
fun main() {
    println("Before creating coroutine")
    runBlocking {
        print("Hello, ")
        delay(200L)
        println("World!")
    }
    println("After coroutine is finished")
}
```

Before creating coroutine  
Hello, World!  
After coroutine is finished

### launch 빌더

독립된 프로세스를 실행하는 코루틴을 시작하고, 해당 코루틴에서 리턴값을 받을 필요가 없다면 launch 코루틴 빌더를 사용하다.  
launch 함수는 CoroutineScope의 확장 함수이기 때문에 CoroutineScope이 사용 가능한 경우에만 사용할 수 있다.

